<div id="article_content" class="article_content">

<p>
B. Ponds <br>
用两个队列来进行模拟， 当某个pond的度数边为1时， 则把其加入待删除序列。 <br>
接着依次扫描待删除序列， 然后更新其他点的度数， 如果被更新的节点度数变为1时， 则将其加入另一个待删除序列。 如此反复。<br>
每个边被遍历一次， 每个点被遍历一次， 复杂度O(n + m)。<br>
</p>

<p><br></p>

<p>
C. Aggreagated Counting <br>
这个题非常赞。  <br>
我们假设原数列为g。 <br>
----------------------------------------------------- <br>
先考虑只求一次的情况， 假如给出一个n， 让你求n最后出现的位置， 设这个操作为last(n)。<br> 
可以发现整个序列的情况肯定是这样：<br>
1个1 2个2 2个3 3个4 3个5 ... f(n-1)个n-1 f(n)个n <br>
其中f(i)就表示i在序列中的数量。 <br>
那么f(i)等于多少呢， 根据g的定义， f(i) == g(i)。 :D <br>
于是last(n) = g(1) + g(2) + g(3) ... + g(n) <br>
----------------------------------------------------- <br>
现在考虑再求一次的情况， 设m = last(n), 那我们求的其实就是last(m)。 <br>
那么在m之前， 肯定有一些数出现了1次， 有一些数出现了2次， 有一些数出现了3次... <br>
比如1出现了1次， 2-3出现了2次， 4-5出现了3次 ... <br>
再合并一下， 就是， 有1个数出现了1次， 有2个数出现了2次， 有2个数出现了3次 ... 有h(i)个数出现了i次 ... <br>
那么m的位置就是  h(1) + 2h(2) + 3h(3) + 4h(4) ... <br>
于是我们的任务就变成了求h(x)。 <br>
将其提取出来单独考虑一下， 整个序列中有几个数字出现了x次？ <br>
根据g的定义， 其实就是x在g序列中出现了几次， 那么就有几个数字出现过x次！ <br>
比如说g序列的开头一些数是 1 2 2 3 3 4 4 4 5 5 5 6 6 6 6 ... <br>
我想求有几个数字出现4次， 其实也就是求4在整个序列中出现了几次。 <br>
而x在g中的数量， 就是上面的f(x), 也就是g(x)。 <br> 
于是有last(m) = g(1) + 2g(2) + 3(g3) + 4g(4) ... + ng(n) <br>
为什么刚好算到g(n)呢？ <br>
因为m = g(1) + g(2) + g(3) ... + g(n) <br>
所以我算到g(n)， 那么最后出现的g(n)个数， 就刚好是g(n)个m。 <br>
------------------------------------------------------- <br>
于是现在的问题变成了， 给定n， 求<br>
g(1) + 2g(2) + 3g(3) ... ng(n)<br>
由于n很大， 直接求解显然不行。<br>
再次根据g序列的性质来解决问题。<br>
思路是因为某些g(i)可能一样， 一样的部分我们可以直接合并它们。 <br>
比如g(2) == g(3)， 那么2g(2) + 3g(3)就可以合并成(2 + 3)g(2)。<br>
那么哪些地方是可以合并的呢？ <br>
我们从1开始， <br>
从1开始有1个数可以合并， g(1) = 1; <br>
从2开始有2个数可以合并， g(2) = g(3) = 2; <br>
从4开始有2个数可以合并， g(4) = g(5) = 3; <br>
... <br>
从li开始， 有ui个数可以合并， g(li) = g(li + 1) = g(li + 2) ... = g(li + ui - 1) = i; <br>
... <br>
如果我们知道了li和ui， 就可以合并一些g的求和操作。 <br>
仔细思考一下， ui表示的其实是g序列中， 有几个数字是i， <br>
比如g(4), g(5) = 3， 那么u3 = 2; <br>
而ui其实就是上面一段中的h(i)， 也就是g(i)了...... <br>
然后打表查看一下， 发现g(1) + g(2) + ... g(500000) >= 1e9。 <br>
于是就按照500000来进行预处理了。 <br>
-------------------------------------------------------- <br>
剩下的就是打表， 计算， 查表， 输出了。 <br>
</p>

<p></br></p>


<p>
E. Travel <br>
把模型转化后， 可看成下面这样：
<br>
对于每个给定的边的阈值d， 先将图中边权大于d的边剔除， 再来看整个图的联通情况。 <br>
比如现在整个图被分成了k个联通块， 每个联通块的大小为a1, a2, a3... ak。
<br>
那么答案就是 C(a1, 2) + C(a2, 2) + C(a3, 2) ...。 其中C是求组合数。
<br>
如果直接对每个d进行计算， 那么肯定会超时。
<br>
于是可以这样：
<br>
先将图中的边按照权值排序， 然后把整个图看作n个大小为1的联通块， 此时整个图的合法点对ANS为0。
<br>
接着依次加入排序后的边， 假设该条边连接的两个联通块大小分别为a, b, 那么我们可以这样更新ANS。
<br>
ANS -= C(a, 2) ANS -= C(b, 2) ANS += C(a + b, 2)。
<br>
接着我们将两边的联通块合并成一个大的联通块。
<br>
这样我们就可以先计算出所有边情况下的答案， 最后每次来一条边， 根据其权值d在之前的答案中二分查找就可以了。
<br>
</p>
<p><br></p>

<p>
F. Favorite Donut
<br>
我们用后缀数组来解决它。
<br>
假设原串为S， 因为环的原因， 我们将其拼接为SS。
<br>
又因为可以逆时针， 我们将SS在反转一下， 拼接在SS后， 形成了SSS'S'， 其中S'就是S的反序。
<br>
然后对这个字符串做后缀数组， 最后得到了sa数组和heigh数组。
<br>
字典序大的串肯定在sa中排在后面， 于是我们从sa数组从后向前扫描， 如果遇到非法情况则跳过。
<br>
当我们找到第一个合法情况时， 比如此时的位置是pos。
<br>
由于最大字典序可能有多种， 但是由于sa数组的性质， 如果还有其他串也是这个最大字典序， 那么这些串一定紧挨在pos上面的位置。
<br>
于是配合heigh数组， 我们找到一个上边界， pos_up。
<br>
其中pos_up到pos这段区间内的字典序都是最大的。
<br>
然后我们用pos_up到pos这段区间内来更新答案， 同样注意排除非法情况。
<br>
</p>

<p><br></p>
<p>
H. Elven Postman
<br>
抽象过后的题目就是给出一棵树的两种根序列， 你需要还原这棵树。
<br>
于是我们先还原这棵树， 然后用string ans[]来记录下这棵树上所有节点的答案。
<br>
最后来一个询问输出一个结果就好。
<br>
</p>

<p><br></p>
<p>
I. Food Problem
<br>
理解题意后， 将整个题目拆分成两个DP。
<br>
DP1求得到P的能量， 最少需要多少空间， 假设为V。
<br>
DP2求得到V的空间， 最少需要付多少钱， 假设为C。
<br>
最后答案就是C。
<br>
但是V的范围最多可以到2e6, 如果直接对V进行背包会超时。
<br>
注意题目input中写C最多为5e5, 所以DP2转化为， 花C的钱， 最多能得到多少V。
<br>
另外由于每个物品都最多能达到100个， 注意二进制压缩一下。
<br>
问题解决。
<br>
</p>

</div>

